import pygame
import time
def solve_queens(n):
    board = [-1] * n
    result = []
    def is_valid(row, col):
        for i in range(row):
            if board[i] == col or abs(row - i) == abs(col - board[i]):
                return False
        return True
    def backtrack(row):
        if row == n:
            result.append(list(board))
            return
        for col in range(n):
            if is_valid(row, col):
                board[row] = col
                backtrack(row + 1)
                board[row] = -1
    backtrack(0)
    return result
def draw_board(screen, solution, n):
    colors = [pygame.Color("white"), pygame.Color("gray")]
    square_size = 60
    for row in range(n):
        for col in range(n):
            color = colors[(row + col) % 2]
            pygame.draw.rect(screen, color, (col*square_size, row*square_size, square_size, square_size))
            if solution[row] == col:
                pygame.draw.circle(screen, pygame.Color("red"), (col*square_size + square_size//2, row*square_size + square_size//2), square_size//3)
def main():
    n = 8
    solutions = solve_queens(n)
    pygame.init()
    square_size = 60
    screen = pygame.display.set_mode((n*square_size, n*square_size))
    pygame.display.set_caption("8-Queens Solver Visualization")
    clock = pygame.time.Clock()
    running = True
    solution_index = 0
    delay = 1.0  
    last_update = time.time()
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
        if time.time() - last_update > delay:
            solution_index = (solution_index + 1) % len(solutions)
            last_update = time.time()
        screen.fill(pygame.Color("black"))
        draw_board(screen, solutions[solution_index], n)
        pygame.display.flip()
        clock.tick(60)
    pygame.quit()
if __name__ == "__main__":
    main()
